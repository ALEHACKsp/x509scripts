#!/bin/sh
# shellcheck shell=bash
#
# This script takes a file that contains a public key and creates a
# certificate and single use CA certificate for the key.  This public
# key may be contained in a certificate, certificate request, private
# key or in a file on it's own.
#
# The CA key is generated in such a way that it should be the same type
# and size as the supplied key.
#
# The remaining arguments are the common name (default localhost) and
# a list of SAN names.
#
# The output can be a pfx file, but if so the file specified with -key=...
# must be a private key or the option omitted completely.
#
# You can do all this:
#   mk-cert -suca -san -pubin=keyfile.crt hostname dnsnames...

if [ -z "$BASH_VERSION" ];then exec bash "$0" "$@";else set +o posix;fi

main() {
    local ar KFNAME PFXNAME KEYFILE CAKEY PUBKEY SERIAL CERT CERTDAYS
    local -a names

    [ "$#" -lt 1 ] && {
	echo >&2 "Usage: $0 [-key=keyfile.pem] [-pfx=file.pfx] common_name [san list]"
	exit 1
    }

    for ar
    do  case "$ar" in
	-key=* )
	    KFNAME="${ar#*[=:]}"
	    KEYFILE="$(cat "$KFNAME")"
	    ;;
	-pfx=* ) PFXNAME="${ar#*[=:]}" ;;
	-* ) echo >&2 "Unknown option '$ar'" ; exit 1 ;;
	* ) names+=( "$ar" ) ;;
	esac
    done

    [ "$KFNAME" = '' ] && {
	if [ "$PFXNAME" != '' ]
	then KEYFILE="$(openssl genrsa)"
	else KEYFILE="$(openssl ecparam -name prime256v1 -genkey -noout)"
	fi
    }

    [ "${#names}" = 0 ] && names+=( localhost )

    [ -n "$KEYFILE" ] &&
	PUBKEY=$(extract_pubkey "$KEYFILE")

    [ "$PUBKEY" = '' ] && {
	echo >&2 "Cannot find public key in $KFNAME, it needs to be unencrypted and in PEM format"
	exit 1
    }

    [ "$CERTDAYS" = '' ] && {
	CERTDAYS=$((24842 - $(date +%s)/86400))
	[ "$CERTDAYS" -lt 3652 ] && CERTDAYS=3652
    }

    SERIAL="$(openssl rand -hex 8)"
    CAKEY=$(make_ca "$PUBKEY" "$SERIAL" "${names[0]}")
    CERT=$(make_cert "$CAKEY" "$SERIAL" "${names[@]}")

    if [ -z "$PFXNAME" ]
    then
	echo "$CERT" | openssl x509 -subject -serial -dates
	echo "$CAKEY" | openssl x509 -subject -serial -dates
	[ "$KFNAME" = '' ] && echo "$KEYFILE"
    else

	openssl pkcs12 -export -passout "pass:" \
	    -out "$PFXNAME" \
	    -name "${names[1]} til: $(echo "$CERT" |
				    openssl x509 -noout -enddate |
				    sed -n 's/.*= *//p')" \
	    -inkey <(echo "$KEYFILE") \
	    -in <(echo "$CERT") \
	    -certfile <(echo "$CAKEY" | openssl x509) \
	    -caname "$(echo "$CAKEY" | openssl x509 -noout \
		    -subject -nameopt multiline | sed -n 's/ *commonName *= //p'
		    ) CA til: $(echo "$CAKEY" | openssl x509 -noout -enddate |
		      sed -n 's/.*= *//p' )"

    fi
    exit 0
}

extract_pubkey() {
    local PUBKEY PEMTYPE ITEM KEYFILE="$1"

    for PEMTYPE in x509 req pkey pubkey rsa ec dsa
    do
        PUBKEY=
	if [ "$PEMTYPE" = 'pubkey' ]
	then ITEM="$(echo "$KEYFILE" | openssl pkey -pubin 2>/dev/null)"
	elif [[ "$PEMTYPE" = rsa || "$PEMTYPE" = dsa || "$PEMTYPE" = ec ]]
	then ITEM="$(echo "$KEYFILE" | openssl "$PEMTYPE" -passin pass:0000 2>/dev/null)"
	else ITEM="$(echo "$KEYFILE" | openssl "$PEMTYPE" 2>/dev/null)"
	fi

	[ "$ITEM" = "" ] && continue

        case "$PEMTYPE" in
        x509 ) PUBKEY="$(echo "$ITEM" | openssl x509 -pubkey -noout 2>/dev/null)" ;;
        req ) PUBKEY="$(echo "$ITEM" | openssl req -pubkey -noout 2>/dev/null)" ;;
        pkey ) PUBKEY="$(echo "$ITEM" | openssl pkey -pubout "${PW[@]}" 2>/dev/null)" ;;
        pubkey ) PUBKEY="$(echo "$ITEM" | openssl pkey -pubin 2>/dev/null)" ;;

        rsa|ec|dsa )
            PUBKEY="$(echo "$ITEM" | openssl "$PEMTYPE" -pubout "${PW[@]}" 2>/dev/null)" ;;
        esac

	[ "$PUBKEY" = "" ] || break
    done

    echo "$PUBKEY"
}

make_ca() {
    local PUBKEY="$1" SERIAL SSKEY SSCERT

    SERIAL="$(openssl rand -hex 8)"
    SSKEY="$(make_a_key "$PUBKEY" )"
    SSCERT="$(openssl req -new -x509 \
	    -days "$CERTDAYS" \
	    -set_serial 0x"$SERIAL" \
	    -key <(echo "$SSKEY") \
	    -config <(
		echo '[req]'
		echo 'distinguished_name = rdn'
		echo 'prompt = no'
		echo 'x509_extensions = x509v3'
		echo '[rdn]'
		[ "$2" != '' ] && echo "dnQualifier=$2"
		echo "O=Above reproach CA"
		echo "CN=$3"
		echo '[x509v3]'
		echo 'basicConstraints = CA:TRUE, pathlen:0'
	    ) )"

    echo "$SSCERT" | openssl x509 -subject -serial -dates
    echo "$SSKEY"
}

make_cert() {
    local CAKEY="$1" SERIAL="$2" CN="$3" NEWCERT
    shift; shift

    make_cert_conf() {
	local SANLIST=''
	SANLIST="$(echo "$*" | xargs)"
	SANLIST="DNS:${SANLIST// /,DNS:}"
	echo '[req]'
	echo 'distinguished_name = rdn'
	echo 'prompt = no'
	[ "$SANLIST" != "" ] && echo 'x509_extensions = x509v3'
	echo '[rdn]'
	# echo "dnQualifier=$SERIAL"
	echo "CN=$CN"
	[ "$SANLIST" != "" ] && {
	    echo '[x509v3]'
	    echo "subjectAltName=$SANLIST"
	}
    }

    [ "$SERIAL" = '' ] && SERIAL="$(openssl rand -hex 8)"
    TMPKEY="$(openssl ecparam -name prime256v1 -genkey -noout)"
    NEWCERT="$(openssl req -new \
	    -key <(echo "$TMPKEY") \
	    -config <(make_cert_conf "$@") |
	    openssl x509 -req \
	    -days "$CERTDAYS" \
	    -set_serial 0x"$SERIAL" \
	    -force_pubkey <(echo "$PUBKEY") \
	    -CA <(echo "$CAKEY") \
            -CAkey <(echo "$CAKEY") \
	    -extfile <(make_cert_conf "$@") -extensions x509v3
	)"

    unset -f make_cert_conf

    echo "$NEWCERT"
}

make_a_key() {
    local INKEY="$1" ECTYPE RSABITS DSALEN DSABITS

    # Match a named EC curve using an ASN1 OID.
    # Recommend:
    #   secp256r1, secp384r1, secp521r1  Supported by browsers.

    ECTYPE=$(echo "$INKEY" | openssl ec -pubin -noout -text 2>&1 |
	awk '/^ASN1 OID:/ {print $3;}')

    # Do we have an EC curve name ?
    [ "$ECTYPE" != "" ] && {
	openssl ecparam -noout -name "$ECTYPE" -genkey
	return
    }

    # Match the RSA bitsize of the key
    RSABITS=$(echo "$INKEY" | openssl rsa -pubin -text -noout 2>&1 |
	awk '/Public.Key: .*bit/{gsub("[^0-9]","",$0); print $0;}')

    # Do we have an RSA bit size ?
    [ "$RSABITS" != "" ] && {
	openssl genrsa "$RSABITS"
	return
    }

    # Match the DSA bitsize of the key
    DSABITS=$(echo "$INKEY" | openssl dsa -pubin -text -noout 2>&1 |
	awk '/Public.Key: .*bit/{gsub("[^0-9]","",$0); print $0;}')

    DSALEN=$(echo "$INKEY" |
        openssl dsa -pubin -modulus -noout 2>/dev/null |
        sed -n 's/.*=//p' | wc -c)
    [ "$DSALEN" -gt 0 ] && DSABITS="$((DSALEN*4/8*8))"

    # Do we have a DSA bit size ?
    [ "$DSABITS" != "" ] && {
	openssl dsaparam -noout -genkey "$DSABITS"
	return
    }

    # Humm, dunno what we had, hopefully this will do.
    openssl ecparam -name prime256v1 -genkey -noout

    return 0
}

main "$@"
