#!/bin/bash -
if [ ! -n "$BASH_VERSION" ];then exec bash "$0" "$@";else set +o posix;fi

# This uses the x509 option of openssl to sign certificates.
# It cannot make CRLs (neither can the crl option)
# It can only issue certificates from the current time for N days.
# It requires an additional config file (from a pipe is OK though)
# It does not require special setup in the standard config
#
# I recommend that new CA's are created for small numbers of related hosts
# in the event of a compromise the CA should be replaced.

main() {

    mkdir -p certs
    CAKEY=certs/ca.pem
    CTYPE=default
    SANS=

    make_cakey

    for host
    do
	cname="$host"
	# Add a ":server" for the type of certificate
        case "$cname" in
	*:* )   CTYPE="${cname##*:}"
		cname="${cname%:*}"
		;;
	esac

	# Use comma seperated names for the SANs
	case "$cname" in
	*,* )
	    SANS="${cname#*,}"
	    cname="${cname%%,*}"
	    ;;
	esac

	fname="$cname"
	# Trim any "*." from the start of the filename.
	case "$fname" in
	\*.* ) fname=${fname#??} ;;
	esac
	fname="certs/${fname:-qik}"

	# Make key, matching the CA
	openssl req -new -nodes \
	    -newkey param:"$CAKEY" \
	    ${cname:+-subj /CN="$cname"} \
	    -keyout "$fname".key |

	# Sign it
	openssl x509 -req -days "$CERT_DAYS" \
	    -set_serial 0x$(openssl rand -hex 16) \
	    -out "$fname".crt \
	    -CA "$CAKEY" -issuer \
	    -extfile <(choose_cert_type "$CTYPE")

	# Windows
	openssl pkcs12 -export -passout pass: -out "$fname".pfx \
		-name "$cname `date`" \
		-inkey "$fname".key -in "$fname".crt
    done
}

make_cakey() {
    [ -s "$CAKEY" ] || {
	openssl req -new -nodes -x509 \
	    ${RSABITS:+-newkey rsa:$RSABITS} \
	    -days ${CERT_DAYS:-7300} \
	    -subj '/CN=Private CA/' \
	    -keyout "$CAKEY" -out "$CAKEY"
    }

    [ "$CERT_DAYS" = "" ] && {
	ENDDAY="$(date +%s --date="$(openssl x509 -noout -enddate -in "$CAKEY" | sed 's/^[^=]*=//')")"
	TODAY="$(date +%s)"
	[ "$ENDDAY" = "" ] && ENDDAY=2147126400
	CERT_DAYS=$(echo $ENDDAY/86400 - $TODAY/86400 | bc)
    }

    CERT_DAYS=${CERT_DAYS:-30}

    if [ "$(openssl pkey -in "$CAKEY" -pubout | openssl dgst)" != \
	 "$(openssl x509 -in "$CAKEY" -noout -pubkey | openssl dgst)" ]
    then
	echo "The private key and certificate key in $CAKEY do NOT match." >&2
	exit 99
    fi

    [ -s certs/ca.crt ] || openssl x509 -in "$CAKEY" -out certs/ca.crt
}

choose_cert_type() {

    [ "$SANS" != "" ] &&
	echo "subjectAltName=DNS:$cname,DNS:${SANS//,/,DNS:}"

    case "$1" in
    none )
	;;

    client )
	echo basicConstraints = CA:false
	echo keyUsage = digitalSignature
	echo extendedKeyUsage = clientAuth
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    server )
	echo basicConstraints = CA:false
	echo keyUsage = keyEncipherment
	echo extendedKeyUsage = serverAuth
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    all )
	echo basicConstraints = CA:false
	echo keyUsage = keyEncipherment,digitalSignature,nonRepudiation
	echo extendedKeyUsage = serverAuth,clientAuth,codeSigning,emailProtection
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    std )
	echo keyUsage = critical,keyEncipherment,digitalSignature
	echo extendedKeyUsage = serverAuth,clientAuth
	echo basicConstraints = critical,CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer
	;;

    openvpn_s )
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	echo nsCertType = server
	;;

    v3|openvpn)
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    default|"" )
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer
	;;

    esac
}

main "$@"
