#!/bin/bash
if [ ! -n "$BASH_VERSION" ];then exec bash "$0" "$@";else set +o posix;fi

main() {
    CAKEY=demoCA/private/cakey.pem
    CACERT=demoCA/cacert.pem
    CATAG=default

    TMP=_ssl_.tmp
    trap "rm -f $TMP.*" 0 1 2

    if [ "$#" -gt 0 ]
    then
	F="$1"
	shift
	case "$F" in 
	*: )
	    CN="${F%:}"
	    F="$CN"
	    ;;
	*:* )
	    CN="${F%:*}"
	    CATAG="${F##*:}"
	    F="$CN"
	   ;;
	* ) CN="$F" ;;
	esac
    else
	F=cert
	unset CN CATAG
    fi

    F=$(echo "$F" | tr -c '[a-zA-Z0-9\.\-\012]' _)

    if [ -f openssl.cnf ]
    then cat openssl.cnf > "$TMP".cnf
    elif [ "$OPENSSL_CONF" != "" -a -s "$OPENSSL_CONF" ]
    then cat "$OPENSSL_CONF" > "$TMP".cnf
    else cat $(openssl version -d | cut -d\" -f2)/openssl.cnf > "$TMP".cnf
    fi
    CONF='-config '"$TMP"'.cnf'
    echo  >> "$TMP".cnf

    # Should use a section for the san list in the req
    echo '[ SANLIST ]' >> "$TMP".cnf
    SANLIST=
    if [ "$#" -gt 0 ]
    then
	SANLIST="subjectAltName=DNS:$CN"
	for san in "$@"
	do
	    [ "$san" = "$CN" ] && continue
	    case "$san" in
	    [0-9]* )
		    SANLIST="$SANLIST,IP:$san"
		    ;;
	    *@* )
		    SANLIST="$SANLIST,email:$san"
		    ;;
	    * )
		    SANLIST="$SANLIST,DNS:$san"
		    ;;
	    esac
	done
	echo "$SANLIST" >> "$TMP".cnf
    fi

    # Note the san list in the request is NOT copied to the cert
    echo '[ dyn_ext ]' >> "$TMP".cnf
    echo "$SANLIST" >> "$TMP".cnf
    choose_cert_type "$CATAG" >> "$TMP".cnf

    # This would setup the copy, but from the ca* section
    # echo copy_extensions=subjectAltName >> "$TMP".cnf

    fix_demoCA

    create_cert
    # create_self_signed_cert

    create_extras
}

fix_demoCA() {
    # Make sure the basics exist in the demoCA directory
    mkdir -p certs demoCA demoCA/private demoCA/newcerts demoCA/certs

    # Recover an existing CA cert & key from the certs directory
    [ ! -s "$CAKEY" -a -s certs/ca.pem ] && {
	openssl pkey -in certs/ca.pem -out "$CAKEY" &&
	openssl x509 -in certs/ca.pem -out "$CACERT" 2>/dev/null
    }

    # We've got a key, but no cert ... okay
    [ -s "$CAKEY" -a ! -s "$CACERT" ] &&
	openssl req $CONF -nodes -new -x509 -days 3652 -subj '/CN=Private CA/' \
	    -key "$CAKEY" -out "$CACERT"

    # No CA around, just make up something.
    [ -s "$CAKEY" ] || {
        # Create a CA key and cert.
	openssl req $CONF -nodes -new -x509 -days 3652 -subj '/CN=Private CA/' \
	    -keyout "$CAKEY" -out "$CACERT"
    }

    # Check the files we've found match.
    PRVKEYID=$(openssl pkey -in "$CAKEY" -pubout | openssl dgst)
    PUBKEYID=$(openssl x509 -in "$CACERT" -noout -pubkey | openssl dgst)

    if [ "$PRVKEYID" != "$PUBKEYID" ]
    then
	echo "The public keys in the CA key and CA certificate do NOT match" >&2
	exit 99
    fi

    # Save an existing CA in a new certs directory
    [ -s "$CACERT" -a -s "$CAKEY" ] && {

	# Checking ...
	if [ "$(openssl x509 -in "$CACERT" 2>&1 | openssl dgst)" != \
	     "$(openssl x509 -in certs/ca.crt 2>&1 | openssl dgst)" ]
	then rm -f certs/ca.crt ||:
	fi
	if [ "$(openssl x509 -in "$CACERT" 2>&1 | openssl dgst)" != \
	     "$(openssl x509 -in certs/ca.pem 2>&1 | openssl dgst)" ]
	then rm -f certs/ca.pem ||:
	fi
	if [ "$(openssl pkey -in "$CAKEY" 2>&1 | openssl dgst)" != \
	     "$(openssl pkey -in certs/ca.pem 2>&1 | openssl dgst)" ]
	then rm -f certs/ca.pem ||:
	fi

	# Recreating.
	[ -s certs/ca.crt ] || openssl x509 -in "$CACERT" -out certs/ca.crt
	[ -s certs/ca.pem ] || {
	    openssl x509 -text -certopt ca_default,no_sigdump -in "$CACERT"
	    openssl pkey -text -in "$CAKEY"
	} > certs/ca.pem
    }

    # Now add the other files.
    [ -f demoCA/index.txt ] || {
	touch demoCA/index.txt

	if [ -s certs/ca.crt ]
	then
	    for i in certs/*.crt
	    do
		SUBJECT=$(openssl x509 -subject -noout -in "$i" | sed 's:^[^/]*= *::')
		SERIAL=$(openssl x509 -serial -noout -in "$i" | sed 's/.*= *//')
		ENDDATE=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$i" -enddate | sed 's/.*= *//')")
		REVOKED=""

		# 32bit workaround.
		[ "$ENDDATE" = "" ] && ENDDATE=20380119031400Z

		if [ "$REVOKED" = "" ]
		then echo -e "V\t$ENDDATE\t\t$SERIAL\tunknown\t$SUBJECT"
		else echo -e "R\t$ENDDATE\t$REVOKED\t$SERIAL\tunknown\t$SUBJECT"
		fi
	    done > demoCA/index.txt
	fi
    }

    [ -f demoCA/index.txt.attr ] || echo unique_subject = no > demoCA/index.txt.attr
    [ -f demoCA/crlnumber ] || echo 00 > demoCA/crlnumber
}

create_cert() {
    # Match the RSA bitsize of the CA
    [ "$ECTYPE$RSABITS$DSABITS" = "" ] &&
	RSABITS=$(openssl rsa -text -noout -in "$CAKEY" 2>&1 |
	    awk '/^Private.Key: .*bit/{gsub("[^0-9]","",$2); print $2;}')

    # Or match the EC type.
    # Recommend:
    #   secp256k1 fast with approx 2^128 brute force.
    #   secp256r1, secp384r1, secp521r1  Supported by Windows 2008 R2.

    [ "$ECTYPE$RSABITS$DSABITS" = "" ] &&
	ECTYPE=$(openssl ec -in "$CAKEY" -noout -text 2>&1 |
	    awk '/^ASN1 OID:/ {print $3;}')

    # Do we have an EC curve type ?
    [ ! -s certs/"$F".key -a "$ECTYPE" != "" ] &&
	openssl ecparam -name "$ECTYPE" -genkey -out certs/"$F".key

    # Do we have a DSA bit size ?
    [ ! -s certs/"$F".key -a "$DSABITS" != "" ] &&
	openssl dsaparam -genkey -out certs/"$F".key $DSABITS

    # If there's no CN openssl/req prompts without properly saving the key.
    [ ! -s certs/"$F".key -a "$CN" = "" ] &&
	openssl genrsa -out certs/"$F".key $RSABITS

    # Make the CSR
    if [ ! -s certs/"$F".key ]
    then
	# Create a request on a new key.
	openssl req $CONF -nodes -new \
	      ${RSABITS:+-newkey rsa:$RSABITS} \
	      ${CN:+-subj /CN="$CN"/} \
	      ${SANLIST:+-reqexts SANLIST} \
	      -keyout certs/"$F".key -out demoCA/certs/"$F".csr
    else
	# Create a request on an existing key.
	openssl req $CONF -nodes -new \
	      ${CN:+-subj /CN="$CN"/} \
	      ${SANLIST:+-reqexts SANLIST} \
	      -key certs/"$F".key -out demoCA/certs/"$F".csr
    fi

    # # Generate a random serial number.
    # openssl rand -hex 16 > demoCA/serial

    # Generate a pseudo random serial number.
    openssl pkey -pubout -in certs/"$F".key | openssl md5 | sed 's/.* //' > demoCA/serial

    # Extract the start and end date from the CA key.
    STRDATE=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$CACERT" -startdate | sed 's/.*=//')")
    ENDDATE=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$CACERT" -enddate | sed 's/.*=//')")

    # 32bit unix time trapper.
    [ "$STRDATE" = "" ] && STRDATE=20000101000000Z
    [ "$ENDDATE" = "" ] && ENDDATE=20380119031400Z

    # Sign the request with the CA key.
    openssl ca \
	-batch \
	$CONF \
	${CN:+-subj /CN="$CN"/} \
	${CATAG:+-extensions dyn_ext} \
	-policy policy_anything \
	-noemailDN \
	-startdate $STRDATE -enddate $ENDDATE \
	-in demoCA/certs/"$F".csr \
	-out demoCA/certs/"$F".crt \
	|| exit

    cp -p demoCA/certs/"$F".crt certs/"$F".crt
}

create_extras() {
    # This seems to be how you make a combined PEM
    {
       openssl x509 -text -certopt ca_default,no_sigdump -in certs/"$F".crt
    #  openssl x509 -text -certopt ca_default,no_sigdump -in "$CACERT"
       openssl pkey -text -in certs/"$F".key
    } > certs/"$F".pem

    # Make a p12 or Windows pfx file (with a blank password!)

    # If the CA certificate is already installed don't include it in the PFX
    openssl pkcs12 \
	-export -passout pass: -out certs/"$F".pfx \
	-name "PFX $CN $(openssl x509 -noout -enddate -in certs/"$F".crt | sed 's/notAfter=/until /')" \
	-inkey certs/"$F".key -in certs/"$F".crt

    # It's not strictly correct to include the CA certificate in the PFX.
    # But Windows will load it into the trusted store when the PFX is
    # loaded into Machine store.
    openssl pkcs12 \
	-export -passout pass: -out certs/"$F".plus-ca.pfx \
	-name "PFX $CN $(openssl x509 -noout -enddate -in certs/"$F".crt | sed 's/notAfter=/until /')" \
	-inkey certs/"$F".key -in certs/"$F".crt \
	-caname "Private CA" -certfile "$CACERT"

}

choose_cert_type() {
    case "$1" in
    none )
	;;

    client )
	echo basicConstraints = CA:false
	echo keyUsage = digitalSignature
	echo extendedKeyUsage = clientAuth
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    server )
	echo basicConstraints = CA:false
	echo keyUsage = keyEncipherment
	echo extendedKeyUsage = serverAuth
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    all )
	echo basicConstraints = CA:false
	echo keyUsage = keyEncipherment,digitalSignature,nonRepudiation
	echo extendedKeyUsage = serverAuth,clientAuth,codeSigning,emailProtection
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    std )
	echo keyUsage = critical,keyEncipherment,digitalSignature
	echo extendedKeyUsage = serverAuth,clientAuth
	echo basicConstraints = critical,CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer
	;;

    openvpn_s )
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	echo nsCertType = server
	;;

    v3|openvpn)
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    default|"" )
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer
	;;

    esac
}

conv_pfx_to_pem() {
    openssl pkcs12 -passin pass: -in "$1".pfx -out "$1".pfx.pem -nodes
}

create_self_signed_cert() {
    openssl req $CONF -new -x509 -days 3652 -nodes \
	-extensions dyn_ext \
	-set_serial 0x$(openssl rand -hex 16) \
	-keyout certs/"$F".key -out certs/"$F".crt \
	${CN:+-subj /CN="$CN"/}
}

main "$@"
