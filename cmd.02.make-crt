#!/bin/bash -
if [ ! -n "$BASH_VERSION" ];then exec bash "$0" "$@";else set +o posix;fi
set -e
export OPENSSL_CONF=/dev/null
CERT_DIR="${CERT_DIR:-certs}"

DIGEST=default
NOPKEY=no

if openssl no-pkey >/dev/null ;then
    NOPKEY=yes
    CERT_DAYS=${CERT_DAYS:-3650}
    DIGEST=sha256
fi

main() {
    CAKEY=demoCA/private/cakey.pem
    CACERT=demoCA/cacert.pem
    CATAG=default
    umask 077

    TMP=_ssl_.tmp
    trap "rm -f $TMP.*" 0 1 2

    if [ "$#" -gt 0 ]
    then
	FN="$1"
	shift
	case "$FN" in
	*: )
	    SUBJ="${FN%:}"
	    ;;
	*:* )
	    SUBJ="${FN%:*}"
	    CATAG="${FN##*:}"
	   ;;
	* ) SUBJ="$FN" ;;
	esac

	case "$SUBJ" in
	"" ) ;;
	/*=* ) ;;
	* ) SUBJ="/CN=$SUBJ/" ;;
	esac
    else
	F=cert
	unset SUBJ CN
    fi

    [ "$F" = "" ] && {
	[ "$CN" = "" ] && { CN="${SUBJ/*\/CN=/}" ; CN="${CN/\/*/}"; }
	F="$CN"
	case "$F" in \*.* ) F=${F#??} ;; esac
	F="${F:-cert}"
    }

    echo Creating CN="$CN"

    F=$(echo "$F" | tr -c 'a-zA-Z0-9\.\-\012' _)

    CONF='-config '"$TMP"'.cnf'
    cat <<-! > "$TMP".cnf
	[ca]
	default_ca = CA_default
	[ CA_default ]
	database = demoCA/index.txt
	default_md = $DIGEST
	serial = demoCA/serial
	default_days = 
	cert_opt = 
	policy = policy_cn
	copy_extensions = copyall
	[policy_cn]
	countryName             = optional
	stateOrProvinceName     = optional
	localityName            = optional
	organizationName        = optional
	organizationalUnitName  = optional
	commonName 				= supplied
	emailAddress            = optional
	dnQualifier		= optional

!

    SANLIST=
    if [ "$#" -gt 0 ]
    then
	if [ "$CN" != "" ]
	then
	    SANLIST="subjectAltName=DNS:$CN"
	    C=,
	else
	    SANLIST="subjectAltName="
	    C=
	fi
	for san in "$@"
	do
	    [ "$san" = "$CN" ] && continue
	    case "$san" in
	    [0-9]* )
		    SANLIST="$SANLIST${C}IP:$san"
		    ;;
	    *@* )
		    SANLIST="$SANLIST${C}email:$san"
		    ;;
	    * )
		    SANLIST="$SANLIST${C}DNS:$san"
		    ;;
	    esac
	    C=,
	done
    fi

    echo '[ dyn_ext ]' >> "$TMP".cnf
    echo "$SANLIST" >> "$TMP".cnf
    [ "$CRLURL" != "" ] && {
	echo "crlDistributionPoints=URI:$CRLURL" >> "$TMP".cnf
    }
    choose_cert_type "$CATAG" >> "$TMP".cnf

    # Should use a section for the san list in the req
    # Note the san list in the request is NOT copied to the cert
    # This would setup the copy, but from the ca* section
    # echo copy_extensions=subjectAltName >> "$TMP".cnf

    fix_demoCA
    create_cert
    create_extras
}

fix_demoCA() {
    # Make sure the basics exist in the demoCA directory
    mkdir -p "$CERT_DIR" demoCA demoCA/private demoCA/newcerts demoCA/certs

    # Recover an existing CA cert & key from the certs directory
    [ ! -s "$CAKEY" -a -s "$CERT_DIR"/ca.pem ] && {
	if [ "$NOPKEY" != yes ] ; then
	    openssl pkey -in "$CERT_DIR"/ca.pem -out "$CAKEY" &&
	    openssl x509 -in "$CERT_DIR"/ca.pem -out "$CACERT" 2>/dev/null
	else
	    openssl rsa -in "$CERT_DIR"/ca.pem -out "$CAKEY" 2>/dev/null &&
	    openssl x509 -in "$CERT_DIR"/ca.pem -out "$CACERT" 2>/dev/null
	fi
    }

    [ ! -s "$CAKEY" -a -s "$CERT_DIR"/ca.key -a ! -s "$CACERT" -a -s "$CERT_DIR"/ca.crt ] && {
	cat "$CERT_DIR"/ca.key > "$CAKEY"
	openssl x509 -in "$CERT_DIR"/ca.crt -out "$CACERT"
    }

    # Now add the other files.
    [ -f demoCA/index.txt.attr ] || echo unique_subject = no > demoCA/index.txt.attr
    [ -f demoCA/crlnumber ] || echo 00 > demoCA/crlnumber
    [ -f demoCA/index.txt ] || {
	touch demoCA/index.txt

	if [ -s "$CERT_DIR"/ca.crt ]
	then
	    > demoCA/crl.txt
	    [ -s "$CERT_DIR"/ca.crl ] && openssl crl -in "$CERT_DIR"/ca.crl -noout -text > demoCA/crl.txt
	    for i in "$CERT_DIR"/*.crt
	    do
		SUBJECT=$(openssl x509 -subject -noout -in "$i" | sed 's:^[^/]*= *::')
		SERIAL=$(openssl x509 -serial -noout -in "$i" | sed 's/.*= *//')
		ENDDATE=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$i" -enddate | sed 's/.*= *//')")
		REVOKED=""

		# 32bit workaround.
		[ "$ENDDATE" = "" ] && ENDDATE=20380119031400Z

		RDATE="$(awk -v serial="$SERIAL" '
		    /Serial Number:/ { enabled = ( $3 == serial ); }
		    enabled && /Revocation Date:/ {
			$1=""; $2=""; print
		    }
		    ' demoCA/crl.txt)"

		[ "$RDATE" != "" ] &&
		    REVOKED="$(TZ=UTC date +%y%m%d%H%M%SZ --date="$RDATE")"

		if [ "$REVOKED" = "" ]
		then echo -e "V\t$ENDDATE\t\t$SERIAL\tunknown\t$SUBJECT"
		else echo -e "R\t$ENDDATE\t$REVOKED\t$SERIAL\tunknown\t$SUBJECT"
		fi
	    done > demoCA/index.txt
	    rm demoCA/crl.txt
	fi
    }

    # We haven't got a proper CA, make one.
    [ -s "$CAKEY" -a -s "$CACERT" ] || {
	echo Creating a CA certificate.
	# First see if the key type is in the ENV
	[ ! -s "$CAKEY" ] &&
	    make_a_key "$CAKEY"

	# No preference? I like this one.
	[ ! -s "$CAKEY" ] &&
	    openssl ecparam -name prime256v1 -genkey -out "$CAKEY"

	[ "$CERT_DAYS" = "" ] && {
	    # No dates, make it huge.
	    CERTSTART=${CERTSTART:-19700101000000Z}
	    CERTEND=${CERTEND:-99991231235959Z}
	}

	# Choose a serial number for the new key
	openssl rand -hex 8 > demoCA/serial

	# Create a cert request
	openssl req -new -nodes -config <(mk_reqconfig) \
		-key "$CAKEY" \
		-subj "/CN=Private CA/dnQualifier=$(cat demoCA/serial)/" \
		-out demoCA/ca.csr

	# Self-sign the CA-certificate
	openssl ca $CONF -batch \
		-selfsign \
		-noemailDN \
		-keyfile "$CAKEY" \
		-out "$CACERT" \
		-in demoCA/ca.csr \
		-outdir demoCA/newcerts \
		-extensions x \
		-extfile <(echo '[x]'; choose_cert_type v3_ca) \
		${CERTSTART:+-startdate $CERTSTART} \
		${CERTEND:+-enddate $CERTEND} \
		${CERT_DAYS:+-days $CERT_DAYS}

	# Don't need the csr
	rm demoCA/ca.csr
    }

    if [ "$NOPKEY" != yes ] ;then
	# Check the CA files match.
	PRVKEYID=$(openssl pkey -in "$CAKEY" -pubout | openssl dgst)
	PUBKEYID=$(openssl x509 -in "$CACERT" -noout -pubkey | openssl dgst)

	if [ "$PRVKEYID" != "$PUBKEYID" ]
	then
	    echo "The public keys in the CA key and CA certificate do NOT match" >&2
	    exit 99
	fi
    fi

    # Save an existing CA in a new certs directory
    [ -s "$CACERT" -a -s "$CAKEY" ] && {

	# Checking ...
	if [ "$(openssl x509 -in "$CACERT" 2>&1 | openssl dgst)" != \
	     "$(openssl x509 -in "$CERT_DIR"/ca.crt 2>&1 | openssl dgst)" ]
	then rm -f "$CERT_DIR"/ca.crt ||:
	fi
	if [ "$(openssl x509 -in "$CACERT" 2>&1 | openssl dgst)" != \
	     "$(openssl x509 -in "$CERT_DIR"/ca.pem 2>&1 | openssl dgst)" ]
	then rm -f "$CERT_DIR"/ca.pem ||:
	fi
	if [ "$(openssl pkey -in "$CAKEY" 2>&1 | openssl dgst)" != \
	     "$(openssl pkey -in "$CERT_DIR"/ca.pem 2>&1 | openssl dgst)" ]
	then rm -f "$CERT_DIR"/ca.pem ||:
	fi

	# Recreating.
	[ -s "$CERT_DIR"/ca.crt ] || openssl x509 -in "$CACERT" -out "$CERT_DIR"/ca.crt
	[ -s "$CERT_DIR"/ca.pem ] || {
	    openssl x509 -subject -serial -dates -in "$CACERT"
	    if [ "$NOPKEY" != yes ] ;then
		openssl pkey -in "$CAKEY"
	    else cat "$CAKEY"
	    fi
	} > "$CERT_DIR"/ca.pem
    }

    # Finally create a current CRL file
    [ "$(grep ^R demoCA/index.txt | wc -l)" -gt 0 -o "$CRLURL" != "" ] && {
	[ "$CERT_DAYS" = "" ] && {
	    ENDDAY="$(date +%s --date="$(openssl x509 -noout -enddate -in "$CACERT" |
		    sed 's/^[^=]*=//')" ||:)"
	    TODAY="$(date +%s)"
	    [ "$ENDDAY" != "" ] &&
		CERT_DAYS=$((ENDDAY/86400 - TODAY/86400))
	}
	CRL_DAYS="${CERT_DAYS:-3650}"

	openssl ca $CONF \
	    -gencrl -crldays $CRL_DAYS \
	    -keyfile "$CAKEY" \
	    -cert "$CACERT" \
	    -out demoCA/crl.pem

	cp demoCA/crl.pem "$CERT_DIR"/ca.crl
    }
    return 0
}

make_a_key() {
    KEYF="$1"

    # Match a named EC curve using an ASN1 OID.
    # Recommend:
    #   secp256k1 fast with approx 2^128 brute force.
    #   secp256r1, secp384r1, secp521r1  Supported by Windows 2008 R2.

    [ "$ECTYPE$RSABITS$DSABITS" = "" -a -s "$CAKEY" ] &&
	ECTYPE=$(openssl ec -in "$CAKEY" -noout -text 2>&1 |
	    awk '/^ASN1 OID:/ {print $3;}')

    # Match the RSA bitsize of the CA
    [ "$ECTYPE$RSABITS$DSABITS" = "" -a -s "$CAKEY" ] &&
	RSABITS=$(openssl rsa -text -noout -in "$CAKEY" 2>&1 |
	    awk '/^Private.Key: .*bit/{gsub("[^0-9]","",$2); print $2;}')

    # Match the DSA bitsize of the CA
    [ "$ECTYPE$RSABITS$DSABITS" = "" -a -s "$CAKEY" ] &&
	DSABITS=$(openssl dsa -text -noout -in "$CAKEY" 2>&1 |
	    awk '/^Private.Key: .*bit/{gsub("[^0-9]","",$2); print $2;}')

    # Do we have an EC curve name ?
    [ ! -s "$KEYF" -a "$ECTYPE" != "" ] &&
	openssl ecparam -name "$ECTYPE" -genkey -out "$KEYF"

    # Do we have an RSA bit size ?
    [ ! -s "$KEYF" -a "$RSABITS" != "" ] &&
	openssl genrsa -out "$KEYF" $RSABITS

    # Do we have a DSA bit size ?
    [ ! -s "$KEYF" -a "$DSABITS" != "" ] &&
	openssl dsaparam -genkey -out "$KEYF" $DSABITS

    return 0
}

create_cert() {

    # If the keytype has been defined use that.
    # If an EC key doesn't have a name "newkey param:" can still copy it.
    # Note: "newkey param:" fails for RSA keys.
    # Note: If there's no CN openssl/req prompts without properly saving the key.
    make_a_key "$CERT_DIR"/"$F".key

    # Make the CSR
    if [ ! -s "$CERT_DIR"/"$F".key ]
    then
       # Create a request on a new key (like the CA).
       openssl req -config <(mk_reqconfig) -nodes -new \
	     -newkey param:"$CACERT" \
	     ${SUBJ:+-subj "$SUBJ"} \
	     -keyout "$CERT_DIR"/"$F".tmpkey -out demoCA/certs/"$F".csr || exit

       mv "$CERT_DIR"/"$F".tmpkey "$CERT_DIR"/"$F".key
    else
       # Create a request on an existing key.
       openssl req -config <(mk_reqconfig) -nodes -new \
	     ${SUBJ:+-subj "$SUBJ"} \
	     -key "$CERT_DIR"/"$F".key -out demoCA/certs/"$F".csr || exit
    fi

    [ "$SUBJ" = "" ] && {
	# If the CN has been reset rename the files.
	NEWF="$(openssl req -noout -in demoCA/certs/"$F".csr -subject | \
		sed -n '/^subject/s/^.*CN[ \t]*=[ \t]*//p' | \
		tr -c 'a-zA-Z0-9\.\-\012' _)"

	if [ "$F" != "$NEWF" -a "$NEWF" != "" ]
	then
		mv "$CERT_DIR"/"$F".key "$CERT_DIR"/"$NEWF".key
		mv demoCA/certs/"$F".csr demoCA/certs/"$NEWF".csr
		F="$NEWF"
	fi
    }

    [ "$CERT_DAYS" = "" ] && {
	# Extract the start and end date from the CA key.
	CERTSTART=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$CACERT" -startdate | sed 's/.*=//')" ||:)
	CERTEND=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$CACERT" -enddate | sed 's/.*=//')" ||:)

	# 32bit unix time trapper.
	[ "$CERTSTART" = "" ] && CERTSTART=20000101000000Z
	[ "$CERTEND" = "" ] && CERTEND=20380119031400Z
    }

    [ -f demoCA/serial ] && mv demoCA/serial demoCA/serial.tmp

    if [ "$CERTSERIAL" != "" ]
    then
	echo "$CERTSERIAL" > demoCA/serial
    else
	# Generate a random serial number.
	openssl rand -hex 8 > demoCA/serial
    fi

    # Sign the request with the CA key.
    openssl ca \
	-batch \
	$CONF \
	${SUBJ:+-subj "$SUBJ"} \
	${CATAG:+-extensions dyn_ext} \
	-noemailDN \
	-keyfile "$CAKEY" \
	-cert "$CACERT" \
	${CERTSTART:+-startdate $CERTSTART} \
	${CERTEND:+-enddate $CERTEND} \
	${CERT_DAYS:+-days $CERT_DAYS} \
	-in demoCA/certs/"$F".csr \
	-out demoCA/certs/"$F".crt \
	-outdir demoCA/newcerts
    RV=$?

    [ -f demoCA/serial.tmp ] && mv demoCA/serial.tmp demoCA/serial
    [ "$RV" -ne 0 ] && exit $RV

    cp -p demoCA/certs/"$F".crt "$CERT_DIR"/"$F".crt
}

create_extras() {
    # This seems to be how you make a combined PEM
    {
	openssl x509 -subject -serial -dates -in "$CERT_DIR"/"$F".crt
    #   openssl x509 -subject -serial -dates -in "$CACERT"
	if [ "$NOPKEY" != yes ] ;then
	    openssl pkey -in "$CERT_DIR"/"$F".key
	else cat "$CERT_DIR"/"$F".key
	fi
    } > "$CERT_DIR"/"$F".pem

    # Make a p12 or Windows pfx file (with a blank password!)

    # If the CA certificate is already installed don't include it in the PFX
    openssl pkcs12 \
	-export -passout pass: -out "$CERT_DIR"/"$F".pfx \
	-name "PFX $CN $(openssl x509 -noout -enddate -in "$CERT_DIR"/"$F".crt | sed 's/notAfter=/until /')" \
	-inkey "$CERT_DIR"/"$F".key -in "$CERT_DIR"/"$F".crt

    # It's not strictly correct to include the CA certificate in the PFX.
    # But Windows will load it into the trusted store when the PFX is
    # loaded into Machine store.
    openssl pkcs12 \
	-export -passout pass: -out "$CERT_DIR"/"$F".plus-ca.pfx \
	-name "PFX $CN $(openssl x509 -noout -enddate -in "$CERT_DIR"/"$F".crt | sed 's/notAfter=/until /')" \
	-inkey "$CERT_DIR"/"$F".key -in "$CERT_DIR"/"$F".crt \
	-certfile "$CACERT" \
	-caname "$(openssl x509 -noout -in "$CERT_DIR"/ca.crt \
		-subject -nameopt multiline | sed -n 's/ *commonName *= //p')"
}

mk_caconfig() {
    echo '[req]'
    echo 'default_bits = 3072'
    echo 'distinguished_name = req_distinguished_name'
    echo 'x509_extensions = v3_ca'
    echo '[v3_ca]'
    echo 'subjectKeyIdentifier=hash'
    echo 'authorityKeyIdentifier=keyid:always,issuer'
    echo 'basicConstraints = CA:true'
    echo '[ req_distinguished_name ]'
}

mk_reqconfig() {
    echo '[req]'
    echo 'default_bits = 3072'
    echo 'distinguished_name = req_distinguished_name'
    echo '[ req_distinguished_name ]'

cat <<\!
countryName                     = Country Name (2 letter code)
countryName_min                 = 2
countryName_max                 = 2
stateOrProvinceName             = State or Province Name (full name)
localityName                    = Locality Name (eg, city)
0.organizationName              = Organization Name (eg, company)
organizationalUnitName          = Organizational Unit Name (eg, section)
commonName                      = Common Name (e.g. server FQDN or YOUR name)
commonName_max                  = 64
commonName_default              = www.example.com
emailAddress                    = Email Address
emailAddress_max                = 64
!

}

choose_cert_type() {
    case "$1" in
    none )
	;;

    client )
	echo basicConstraints = CA:false
	echo keyUsage = digitalSignature
	echo extendedKeyUsage = clientAuth
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    server )
	echo basicConstraints = CA:false
	echo keyUsage = keyEncipherment
	echo extendedKeyUsage = serverAuth
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    all )
	echo basicConstraints = CA:false
	echo keyUsage = keyEncipherment,digitalSignature,nonRepudiation
	echo extendedKeyUsage = serverAuth,clientAuth,codeSigning,emailProtection
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    std )
	echo keyUsage = critical,keyEncipherment,digitalSignature
	echo extendedKeyUsage = serverAuth,clientAuth
	echo basicConstraints = critical,CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer
	;;

    v3)
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    default|"" )
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer
	;;

    v3_ca )
	echo 'subjectKeyIdentifier=hash'
	echo 'authorityKeyIdentifier=keyid:always,issuer'
	echo 'basicConstraints = CA:true'
	;;

    esac
}

conv_pfx_to_pem() {
    openssl pkcs12 -passin pass: -in "$1".pfx -out "$1".pfx.pem -nodes
}

main "$@"
