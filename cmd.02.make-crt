#!/bin/bash
if [ ! -n "$BASH_VERSION" ];then exec bash "$0" "$@";else set +o posix;fi
set -e
export OPENSSL_CONF=/dev/null

main() {
    CAKEY=demoCA/private/cakey.pem
    CACERT=demoCA/cacert.pem
    CATAG=default

    TMP=_ssl_.tmp
    trap "rm -f $TMP.*" 0 1 2

    if [ "$#" -gt 0 ]
    then
	F="$1"
	shift
	case "$F" in 
	*: )
	    CN="${F%:}"
	    F="$CN"
	    ;;
	*:* )
	    CN="${F%:*}"
	    CATAG="${F##*:}"
	    F="$CN"
	   ;;
	* ) CN="$F" ;;
	esac
    else
	F=cert
	unset CN
    fi

    F=$(echo "$F" | tr -c '[a-zA-Z0-9\.\-\012]' _)

    CONF='-config '"$TMP"'.cnf'
    cat <<-! > "$TMP".cnf
	[ca]
	default_ca = CA_default
	[ CA_default ]
	database = demoCA/index.txt
	default_md = default
	serial = demoCA/serial
	default_days = 
	cert_opt = 
	policy = policy_cn
	copy_extensions = copyall
	[policy_cn]
	countryName             = optional
	stateOrProvinceName     = optional
	localityName            = optional
	organizationName        = optional
	organizationalUnitName  = optional
	commonName 				= supplied
	emailAddress            = optional

!

    # Should use a section for the san list in the req
    echo '[ SANLIST ]' >> "$TMP".cnf
    SANLIST=
    if [ "$#" -gt 0 ]
    then
	SANLIST="subjectAltName=DNS:$CN"
	for san in "$@"
	do
	    [ "$san" = "$CN" ] && continue
	    case "$san" in
	    [0-9]* )
		    SANLIST="$SANLIST,IP:$san"
		    ;;
	    *@* )
		    SANLIST="$SANLIST,email:$san"
		    ;;
	    * )
		    SANLIST="$SANLIST,DNS:$san"
		    ;;
	    esac
	done
	echo "$SANLIST" >> "$TMP".cnf
    fi

    # Note the san list in the request is NOT copied to the cert
    echo '[ dyn_ext ]' >> "$TMP".cnf
    echo "$SANLIST" >> "$TMP".cnf
    [ "$CRLURL" != "" ] && {
	echo "crlDistributionPoints=URI:$CRLURL" >> "$TMP".cnf
    }
    choose_cert_type "$CATAG" >> "$TMP".cnf

    # This would setup the copy, but from the ca* section
    # echo copy_extensions=subjectAltName >> "$TMP".cnf

    fix_demoCA
    create_cert
    create_extras
}

fix_demoCA() {
    # Make sure the basics exist in the demoCA directory
    mkdir -p certs demoCA demoCA/private demoCA/newcerts demoCA/certs

    # Recover an existing CA cert & key from the certs directory
    [ ! -s "$CAKEY" -a -s certs/ca.pem ] && {
	openssl pkey -in certs/ca.pem -out "$CAKEY" &&
	openssl x509 -in certs/ca.pem -out "$CACERT" 2>/dev/null

	[ ! -s "$CAKEY" -a -s certs/ca.key ] &&
	    openssl pkey -in certs/ca.pem -out "$CAKEY"
	[ ! -s "$CACERT" -a -s certs/ca.crt ] &&
	    openssl x509 -in certs/ca.crt -out "$CACERT"
    }

    # Now add the other files.
    [ -f demoCA/index.txt.attr ] || echo unique_subject = no > demoCA/index.txt.attr
    [ -f demoCA/crlnumber ] || echo 00 > demoCA/crlnumber
    [ -f demoCA/index.txt ] || {
	touch demoCA/index.txt

	if [ -s certs/ca.crt ]
	then
	    > demoCA/crl.txt
	    [ -s certs/ca.crl ] && openssl crl -in certs/ca.crl -noout -text > demoCA/crl.txt
	    for i in certs/*.crt
	    do
		SUBJECT=$(openssl x509 -subject -noout -in "$i" | sed 's:^[^/]*= *::')
		SERIAL=$(openssl x509 -serial -noout -in "$i" | sed 's/.*= *//')
		ENDDATE=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$i" -enddate | sed 's/.*= *//')")
		REVOKED=""

		# 32bit workaround.
		[ "$ENDDATE" = "" ] && ENDDATE=20380119031400Z

		RDATE="$(awk -v serial=$SERIAL '
		    /Serial Number:/ { enabled = ( $3 == serial ); }
		    enabled && /Revocation Date:/ {
			$1=""; $2=""; print
		    }
		    ' demoCA/crl.txt)"

		[ "$RDATE" != "" ] &&
		    REVOKED="$(TZ=UTC date +%y%m%d%H%M%SZ --date="$RDATE")"

		if [ "$REVOKED" = "" ]
		then echo -e "V\t$ENDDATE\t\t$SERIAL\tunknown\t$SUBJECT"
		else echo -e "R\t$ENDDATE\t$REVOKED\t$SERIAL\tunknown\t$SUBJECT"
		fi
	    done > demoCA/index.txt
	    rm demoCA/crl.txt
	fi
    }

    # We haven't got a proper CA, make one.
    [ -s "$CAKEY" -a -s "$CACERT" ] || {
	echo Creating a CA certificate.
	# First see if the key type is in the ENV
	[ ! -s "$CAKEY" ] &&
	    make_a_key "$CAKEY"

	# No preference? I like this one.
	[ ! -s "$CAKEY" ] &&
	    openssl ecparam -name prime256v1 -genkey -out "$CAKEY"

	# No dates, make it huge.
	CERTSTART=${CERTSTART:-19700101000000Z}
	CERTEND=${CERTEND:-99991231235959Z}

	# Choose a serial number for the new key
	openssl pkey -pubout -in "$CAKEY" | openssl md5 | sed 's/.* //' > demoCA/serial

	# Create a cert request
	openssl req -new -nodes -config <(mk_reqconfig) \
		-key "$CAKEY" \
		-subj "/CN=Private CA/" \
		-out demoCA/private/ca.csr

	# Self-sign the CA-certificate
	openssl ca $CONF -batch \
		-selfsign \
		-noemailDN \
		-keyfile "$CAKEY" \
		-out "$CACERT" \
		-in demoCA/private/ca.csr \
		-outdir demoCA/newcerts \
		-extensions x \
		-extfile <(echo '[x]'; choose_cert_type v3_ca) \
		-startdate $CERTSTART  -enddate $CERTEND

	# Don't need the csr
	rm demoCA/private/ca.csr
    }

    # Check the CA files match.
    PRVKEYID=$(openssl pkey -in "$CAKEY" -pubout | openssl dgst)
    PUBKEYID=$(openssl x509 -in "$CACERT" -noout -pubkey | openssl dgst)

    if [ "$PRVKEYID" != "$PUBKEYID" ]
    then
	echo "The public keys in the CA key and CA certificate do NOT match" >&2
	exit 99
    fi

    # Save an existing CA in a new certs directory
    [ -s "$CACERT" -a -s "$CAKEY" ] && {

	# Checking ...
	if [ "$(openssl x509 -in "$CACERT" 2>&1 | openssl dgst)" != \
	     "$(openssl x509 -in certs/ca.crt 2>&1 | openssl dgst)" ]
	then rm -f certs/ca.crt ||:
	fi
	if [ "$(openssl x509 -in "$CACERT" 2>&1 | openssl dgst)" != \
	     "$(openssl x509 -in certs/ca.pem 2>&1 | openssl dgst)" ]
	then rm -f certs/ca.pem ||:
	fi
	if [ "$(openssl pkey -in "$CAKEY" 2>&1 | openssl dgst)" != \
	     "$(openssl pkey -in certs/ca.pem 2>&1 | openssl dgst)" ]
	then rm -f certs/ca.pem ||:
	fi

	# Recreating.
	[ -s certs/ca.crt ] || openssl x509 -in "$CACERT" -out certs/ca.crt
	[ -s certs/ca.pem ] || {
	    openssl x509 -subject -serial -dates -in "$CACERT"
	    openssl pkey -in "$CAKEY"
	} > certs/ca.pem
    }

    # Finally create a current CRL file
    [ "$(grep ^R demoCA/index.txt | wc -l)" -ge 0 ] && {
	[ "$CERT_DAYS" = "" ] && {
	    ENDDAY="$(date +%s --date="$(openssl x509 -noout -enddate -in "$CACERT" |
		    sed 's/^[^=]*=//')" ||:)"
	    TODAY="$(date +%s)"
	    [ "$ENDDAY" != "" ] &&
		CERT_DAYS=$((ENDDAY/86400 - TODAY/86400))
	}
	CRL_DAYS="${CERT_DAYS:-3650}"

	openssl ca $CONF \
	    -gencrl -crldays $CRL_DAYS \
	    -keyfile "$CAKEY" \
	    -cert "$CACERT" \
	    -out demoCA/crl.pem

	cp demoCA/crl.pem certs/ca.crl
    }
    return 0
}

make_a_key() {
    KEYF="$1"

    # Match a named EC curve using an ASN1 OID.
    # Recommend:
    #   secp256k1 fast with approx 2^128 brute force.
    #   secp256r1, secp384r1, secp521r1  Supported by Windows 2008 R2.

    [ "$ECTYPE$RSABITS$DSABITS" = "" -a -s "$CAKEY" ] &&
	ECTYPE=$(openssl ec -in "$CAKEY" -noout -text 2>&1 |
	    awk '/^ASN1 OID:/ {print $3;}')

    # Match the RSA bitsize of the CA
    [ "$ECTYPE$RSABITS$DSABITS" = "" -a -s "$CAKEY" ] &&
	RSABITS=$(openssl rsa -text -noout -in "$CAKEY" 2>&1 |
	    awk '/^Private.Key: .*bit/{gsub("[^0-9]","",$2); print $2;}')

    # Match the DSA bitsize of the CA
    [ "$ECTYPE$RSABITS$DSABITS" = "" -a -s "$CAKEY" ] &&
	DSABITS=$(openssl dsa -text -noout -in "$CAKEY" 2>&1 |
	    awk '/^Private.Key: .*bit/{gsub("[^0-9]","",$2); print $2;}')

    # Do we have an EC curve name ?
    [ ! -s "$KEYF" -a "$ECTYPE" != "" ] &&
	openssl ecparam -name "$ECTYPE" -genkey -out "$KEYF"

    # Do we have an RSA bit size ?
    [ ! -s "$KEYF" -a "$RSABITS" != "" ] &&
	openssl genrsa -out "$KEYF" $RSABITS

    # Do we have a DSA bit size ?
    [ ! -s "$KEYF" -a "$DSABITS" != "" ] &&
	openssl dsaparam -genkey -out "$KEYF" $DSABITS

    return 0
}

create_cert() {

    # If the keytype has been defined use that.
    # If an EC key doesn't have a name "newkey param:" can still copy it.
    # Note: "newkey param:" fails for RSA keys.
    # Note: If there's no CN openssl/req prompts without properly saving the key.
    make_a_key certs/"$F".key

    # Make the CSR
    if [ ! -s certs/"$F".key ]
    then
       # Create a request on a new key (like the CA).
       openssl req -config <(mk_reqconfig) -nodes -new \
	     -newkey param:"$CACERT" \
	     ${CN:+-subj /CN="$CN"/} \
	     -keyout certs/"$F".tmpkey -out demoCA/certs/"$F".csr || exit

       mv certs/"$F".tmpkey certs/"$F".key
    else
       # Create a request on an existing key.
       openssl req -config <(mk_reqconfig) -nodes -new \
	     ${CN:+-subj /CN="$CN"/} \
	     -key certs/"$F".key -out demoCA/certs/"$F".csr || exit
    fi

    # For a 'real' CA the SANLIST will be copied from the request
    #	     ${SANLIST:+-reqexts SANLIST} \

    # If the CN has been reset rename the files.
    NEWF="$(openssl req -noout -in demoCA/certs/"$F".csr -subject | \
	    sed -n '/^subject/s/^.*CN[ \t]*=[ \t]*//p' | \
	    tr -c '[a-zA-Z0-9\.\-\012]' _)"

    if [ "$F" != "$NEWF" -a "$NEWF" != "" ]
    then
	    mv certs/"$F".key certs/"$NEWF".key
	    mv demoCA/certs/"$F".csr demoCA/certs/"$NEWF".csr
	    F="$NEWF"
    fi

    # Extract the start and end date from the CA key.
    STRDATE=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$CACERT" -startdate | sed 's/.*=//')" ||:)
    ENDDATE=$(TZ=UTC date +%Y%m%d%H%M%SZ --date="$(openssl x509 -noout -in "$CACERT" -enddate | sed 's/.*=//')" ||:)

    # 32bit unix time trapper.
    [ "$STRDATE" = "" ] && STRDATE=20000101000000Z
    [ "$ENDDATE" = "" ] && ENDDATE=20380119031400Z

    [ -f demoCA/serial ] && mv demoCA/serial demoCA/serial.tmp

    if [ "$CERTSERIAL" != "" ]
    then
	echo "$CERTSERIAL" > demoCA/serial
    else
	# # Generate a random serial number.
	# openssl rand -hex 16 > demoCA/serial

	# Generate a pseudo random serial number.
	openssl pkey -pubout -in certs/"$F".key | openssl md5 | sed 's/.* //' > demoCA/serial
    fi

    # Sign the request with the CA key.
    openssl ca \
	-batch \
	$CONF \
	${CN:+-subj /CN="$CN"/} \
	${CATAG:+-extensions dyn_ext} \
	-noemailDN \
	-keyfile "$CAKEY" \
	-cert "$CACERT" \
	-startdate $STRDATE -enddate $ENDDATE \
	-in demoCA/certs/"$F".csr \
	-out demoCA/certs/"$F".crt \
	-outdir demoCA/newcerts
    RV=$?

    [ -f demoCA/serial.tmp ] && mv demoCA/serial.tmp demoCA/serial
    [ "$RV" -ne 0 ] && exit $RV

    cp -p demoCA/certs/"$F".crt certs/"$F".crt
}

create_extras() {
    # This seems to be how you make a combined PEM
    {
       openssl x509 -subject -serial -dates -in certs/"$F".crt
    #  openssl x509 -subject -serial -dates -in "$CACERT"
       openssl pkey -in certs/"$F".key
    } > certs/"$F".pem

    # Make a p12 or Windows pfx file (with a blank password!)

    # If the CA certificate is already installed don't include it in the PFX
    openssl pkcs12 \
	-export -passout pass: -out certs/"$F".pfx \
	-name "PFX $CN $(openssl x509 -noout -enddate -in certs/"$F".crt | sed 's/notAfter=/until /')" \
	-inkey certs/"$F".key -in certs/"$F".crt

    # It's not strictly correct to include the CA certificate in the PFX.
    # But Windows will load it into the trusted store when the PFX is
    # loaded into Machine store.
    openssl pkcs12 \
	-export -passout pass: -out certs/"$F".plus-ca.pfx \
	-name "PFX $CN $(openssl x509 -noout -enddate -in certs/"$F".crt | sed 's/notAfter=/until /')" \
	-inkey certs/"$F".key -in certs/"$F".crt \
	-certfile "$CACERT" \
	-caname "$(openssl x509 -noout -in certs/ca.crt \
		-subject -nameopt multiline | sed -n 's/ *commonName *= //p')"
}

mk_caconfig() {
    echo '[req]'
    echo 'default_bits = 3072'
    echo 'distinguished_name = req_distinguished_name'
    echo 'x509_extensions = v3_ca'
    echo '[v3_ca]'
    echo 'subjectKeyIdentifier=hash'
    echo 'authorityKeyIdentifier=keyid:always,issuer'
    echo 'basicConstraints = CA:true'
    echo '[ req_distinguished_name ]'
}

mk_reqconfig() {
    echo '[req]'
    echo 'default_bits = 3072'
    echo 'distinguished_name = req_distinguished_name'
    echo '[ req_distinguished_name ]'

cat <<\!
countryName                     = Country Name (2 letter code)
countryName_min                 = 2
countryName_max                 = 2
stateOrProvinceName             = State or Province Name (full name)
localityName                    = Locality Name (eg, city)
0.organizationName              = Organization Name (eg, company)
organizationalUnitName          = Organizational Unit Name (eg, section)
commonName                      = Common Name (e.g. server FQDN or YOUR name)
commonName_max                  = 64
commonName_default              = www.example.com
emailAddress                    = Email Address
emailAddress_max                = 64
!

}

choose_cert_type() {
    case "$1" in
    none )
	;;

    client )
	echo basicConstraints = CA:false
	echo keyUsage = digitalSignature
	echo extendedKeyUsage = clientAuth
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    server )
	echo basicConstraints = CA:false
	echo keyUsage = keyEncipherment
	echo extendedKeyUsage = serverAuth
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    all )
	echo basicConstraints = CA:false
	echo keyUsage = keyEncipherment,digitalSignature,nonRepudiation
	echo extendedKeyUsage = serverAuth,clientAuth,codeSigning,emailProtection
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    std )
	echo keyUsage = critical,keyEncipherment,digitalSignature
	echo extendedKeyUsage = serverAuth,clientAuth
	echo basicConstraints = critical,CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer
	;;

    openvpn_s )
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	echo nsCertType = server
	;;

    v3|openvpn)
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer:always
	;;

    default|"" )
	echo basicConstraints = CA:false
	echo subjectKeyIdentifier=hash
	echo authorityKeyIdentifier=keyid,issuer
	;;

    v3_ca )
	echo 'subjectKeyIdentifier=hash'
	echo 'authorityKeyIdentifier=keyid:always,issuer'
	echo 'basicConstraints = CA:true'
	;;

    esac
}

conv_pfx_to_pem() {
    openssl pkcs12 -passin pass: -in "$1".pfx -out "$1".pfx.pem -nodes
}

main "$@"
