#!/bin/bash -
if [ ! -n "$BASH_VERSION" ];then exec bash "$0" "$@";else set +o posix;fi

umask 077
export OPENSSL_CONF=/dev/null
CERT_DIR="${CERT_DIR:-certs}"

[ -d "$CERT_DIR" ] || { echo >&2 ERROR: Certificate directory missing ; exit 1;}

build_files() {

mkdir -p tmp ovpn-conf

SERVERCOUNT=0
SERVERNAME=
SERVEROU=

# Add all the server CA certificates.
for CA in "$CERT_DIR"/*.ca.cer
do
    [ -s "$CA" ] || continue
    [ -s "${CA/.ca.cer/.crt}" ] || continue
    [ -s "${CA/.ca.cer/.key}" ] || continue

    openssl x509 -subject -serial -dates -in "$CA"

    SERVERCOUNT=$((SERVERCOUNT+1))
    SERVERNAME="$(openssl x509 -noout -in "${CA/.ca.cer/.crt}" \
	-subject -nameopt multiline | sed -n 's/ *commonName *= //p')"

    OU="$(openssl x509 -noout -in "${CA/.ca.cer/.crt}" -subject \
	-nameopt multiline | sed -n 's/ *organizationalUnitName *= //p')"

    # If they have a common OU
    if [ "$SERVERCOUNT" = 1 ]
    then SERVEROU="$OU"
    else [ "$OU" != "$SERVEROU" ] && SERVEROU=""
    fi

done > tmp/servers.CA-list.pem

[ -s tmp/servers.CA-list.pem ] || {
    rm -rf tmp
    echo >&2 ERROR: No servers have been defined.
    exit 1
}

# Protect the TLS handshake from s-kiddies.
[ -f "$CERT_DIR"/tls-crypt.pvk ] ||
    openvpn --genkey --secret "$CERT_DIR"/tls-crypt.pvk

rm -f tmp/clients.CA-list.pem ||:

# For all the client CA certificates
for cert in "$CERT_DIR"/*.ca.crt
do
    CN="$(basename "$cert" .ca.crt)"
    CA="$CERT_DIR/$CN.ca.crt"

    [ -s "$CA" ] || continue

    echo Client $CN

    rm -f tmp/client.key tmp/client.crt tmp/client.ca tmp/client.pfx tmp/client.pem

    [ -s "$CERT_DIR"/"$CN".key ] && cat "$CERT_DIR"/"$CN".key >> tmp/client.pem
    [ -s "$CERT_DIR"/"$CN".crt ] && cat "$CERT_DIR"/"$CN".crt >> tmp/client.pem
    [ -s "$CERT_DIR"/"$CN".pem ] && cat "$CERT_DIR"/"$CN".pem >> tmp/client.pem
    cat "$CA" >> tmp/client.pem

    # This checks the certificates and allows us to put them anywhere
    openssl pkcs12 -export -in tmp/client.pem -CAfile tmp/client.pem -chain -passout pass: -out tmp/client.pfx

    [ -s tmp/client.pfx ] || continue

    openssl pkcs12 -in tmp/client.pfx -passin pass: -clcerts -nokeys -nodes -nomacver > tmp/client.crt
    openssl pkcs12 -in tmp/client.pfx -passin pass: -cacerts -nokeys -nodes -nomacver > tmp/client.ca
    openssl pkcs12 -in tmp/client.pfx -passin pass: -nocerts -nodes -nomacver > tmp/client.key

    [ -s tmp/client.ca ] || cp tmp/client.crt tmp/client.ca

    [ -s tmp/client.key ] || continue
    [ -s tmp/client.crt ] || continue

    # Check them.
    CERTPUB="$(openssl x509 -pubkey -noout < tmp/client.crt 2>/dev/null)"
    PKEYPUB="$(openssl pkey -pubout < tmp/client.key 2>/dev/null)"
    SUBJ="$(openssl x509 -subject_hash -noout < tmp/client.ca 2>/dev/null)"
    CASER="$(openssl x509 -serial -noout < tmp/client.ca 2>/dev/null)"
    ISSU="$(openssl x509 -issuer_hash -noout < tmp/client.crt 2>/dev/null)"

    if [ "$CERTPUB" != "$PKEYPUB" ]
    then echo "WARNING: Skipped $CA, public keys don't match"
	 continue
    fi

    if [ "$SUBJ" != "$ISSU" ]
    then echo "WARNING: Skipped $CA, issuer doesn't match signer subject"
	 continue
    fi

    VERIFYED=$(openssl verify -x509_strict -check_ss_sig -purpose sslclient \
	    -CAfile tmp/client.ca tmp/client.crt 2>&1 | grep -iq ^error &&
	echo no || echo yes)

    if [ "$VERIFYED" = no ]
    then echo "WARNING: Skipped $CA, openssl verify gave error"
	 continue
    fi

    USAGE=$(openssl x509 -purpose -noout -in tmp/client.crt 2>/dev/null |
	    grep -q 'SSL client *: *Yes' &&
	echo yes || echo no)

    if [ "$USAGE" = no ]
    then echo "WARNING: Skipped $CA, not usable as client certificate"
	 continue
    fi

    if [ ! -f "tmp/$SUBJ.$CASER.flg" ]
    then
	{
	    openssl x509 -subject -serial -dates -in tmp/client.ca
	    echo
	} >> tmp/clients.CA-list.pem
	touch "tmp/$SUBJ.$CASER.flg"
    fi

    for file in pattern*.ovpn
    do
	if [ -f "$file" ]
	then tfile="$CN${file/pattern/}"
	else file=/dev/null
	     tfile="$CN.ovpn"
	fi

	{
	    cat "$file"
	    echo

	    # Stop the deamon whinging.
	    # This has NO security effect as the CAs are unique.
	    # (Even if the clients are the same OU)
	    if [ "$SERVERCOUNT" -eq 1 -a "$SERVERNAME" != "" ]
	    then
		# Not on 2.4.1 Windows, ENABLE_X509ALTUSERNAME missing
		# echo x509-username-field CN
		echo "verify-x509-name '$SERVERNAME' name"
	    elif [ "$SERVEROU" != "" ]
	    then
		echo x509-username-field OU
		echo "verify-x509-name '$SERVEROU' name"
	    fi
	    echo

	    [ -s "$CERT_DIR"/tls-crypt.pvk ] && {
		if ! grep -q tls-auth "$file"
		then
		    echo '<tls-crypt>'
		    cat "$CERT_DIR"/tls-crypt.pvk
		    echo '</tls-crypt>'
		fi
	    }

	    echo '<cert>'
	    openssl x509 -subject -serial -dates -in tmp/client.crt
	    echo '</cert>'

	    echo '<key>'
	    openssl pkey -in tmp/client.key
	    echo '</key>'

	    echo '<ca>'
	    cat tmp/servers.CA-list.pem
	    echo '</ca>'

	} > tmp/"$tfile"

	rm -f tmp/client.key tmp/client.crt ||:
	try_file ovpn-conf "$tfile"
    done

done

[ -s tmp/clients.CA-list.pem ] || {
    rm -rf tmp
    echo >&2 ERROR: No clients have been defined.
    exit 1
}

# Copy all the certificates and keys for the servers.
for cert in "$CERT_DIR"/*.ca.cer
do
    [ -s "$cert" ] || continue
    [ -s "${cert/.ca.cer/.crt}" ] || continue
    [ -s "${cert/.ca.cer/.key}" ] || continue

    CN="$(basename "$cert" .ca.cer)"
    echo Server $CN

    openssl x509 -subject -serial -dates -in "$CERT_DIR"/"$CN".crt > tmp/"$CN".crt
    openssl pkey -in "$CERT_DIR"/"$CN".key > tmp/"$CN".key

    cp -p tmp/clients.CA-list.pem tmp/"$CN".ca-list.pem

    cp -p "$CERT_DIR"/tls-crypt.pvk tmp/"$CN".tls-crypt.pvk

    try_file ovpn-conf "$CN".crt
    try_file ovpn-conf "$CN".key
    try_file ovpn-conf "$CN".ca-list.pem
    try_file ovpn-conf "$CN".tls-crypt.pvk

    [ -f "$CERT_DIR"/dhparam.pem ] && {
	cp -p "$CERT_DIR"/dhparam.pem tmp/"$CN".dhparam.pem
	try_file ovpn-conf "$CN".dhparam.pem
    }
done

rm -rf tmp
}

try_file() {
    [ ! -s "$1"/"$2" ] &&
	cp -p tmp/"$2" "$1"/"$2"
    if ! cmp -s tmp/"$2" "$1"/"$2"
    then cp -p tmp/"$2" "$1"/"$2"
    fi
    [ -f tmp/"$2" ] && rm tmp/"$2"
}

build_files
